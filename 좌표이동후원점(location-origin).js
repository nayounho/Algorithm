// 문제 설명
// 4방향으로 움직일 수 있는 로봇이 좌표평면의 원점에 서 있습니다. 이 로봇에게 알파벳으로 명령을 내려 특정 방향으로 1칸만큼 이동을 시킬 수 있습니다. 로봇은 4방향으로 움직일 수 있으며, U는 위, L은 왼쪽, R은 오른쪽, D는 아래로 이동하라는 명령어입니다. 로봇에게 명령을 하나의 문자열로 묶어서 내릴 수 있습니다. 예를 들어, 로봇에게 다음과 같은 명령을 내렸다고 가정해 봅시다.

// URLLDRLR

// 로봇은 (0,0) → (0,1) → (1,1) → (0,1) → (-1,1) → (-1,0) → (0,0) → (-1,0) → (0,0) 의 순서로 이동하여 원점으로 돌아오게 됩니다. 하지만 우리는 이 명령어 중 연속되는 일부 명령어만을 내려도 원점으로 돌아오게 할 수 있습니다. 그 경우는 다음과 같습니다.

// 명령어    명령어의 범위(a번째 문자열~b번째 문자열을 의미)
// RL    [1,2]
// RL    [5,6]
// LR    [6,7]
// URLLDR    [0,5]
// URLLDRLR    [0,7] ※명령어 전체도 포함
// 결론적으로 위의 명령어의 전체, 또는 연속되는 일부 명령어 중 로봇이 출발하여 시작지점으로 돌아오는 경우의 수는 5가지입니다.

// 로봇의 명령어 s가 주어질 때, 경우의 수를 return 하는 solution 함수를 완성해 주세요.

// 제한사항
// 'R', 'L', 'U', 'D' 이외에 명령어는 주어지지 않습니다.
// 명령어 s의 길이 : 1,000 이하의 자연수
// 입출력 예
// s    result
// "URLLDRLR"    5
// "RLDU"    3
// "URDLDRULDLRUDLU"    14
// 입출력 예 설명
// 입출력 예 #1
// 문제의 예시와 같습니다.

// 입출력 예 #2
// 0번째 문자열부터 1번째 문자열인 "RL", 2번째 문자열부터 3번째 문자열인 "DU", 0번째 문자열부터 3번째 문자열인 "RLDU" 의 3가지 경우가 원점으로 돌아오게 할 수 있습니다. 그러므로 3을 return 하면 됩니다.

// 입출력 예 #3
// 위와 같은 방식으로 하면 됩니다.

function solution(s) {
  let robot = [0, 0];
  let arr = s.split("");
  let count = 0;

  do {
    arr.forEach(v => {
      if (v === "U") {
        robot[1] += 1;
        if (robot[0] === 0 && robot[1] === 0) count++;
      } else if (v === "D") {
        robot[1] -= 1;
        if (robot[0] === 0 && robot[1] === 0) count++;
      } else if (v === "R") {
        robot[0] += 1;
        if (robot[0] === 0 && robot[1] === 0) count++;
      } else if (v === "L") {
        robot[0] -= 1;
        if (robot[0] === 0 && robot[1] === 0) count++;
      }
    });

    arr.shift();
    robot = [0, 0];
  } while (arr.length > 0);

  return count;
}

console.log(solution("URDLDRULDLRUDLU"));
